import contextlib
import logging
import secrets
from typing import Annotated

from cachetools import TTLCache
from fastapi import Cookie

from password_admin.auth import LoginCredentials
from password_admin.database.factory import DbConnectionFactory
from password_admin.database.interface import DbConnectionInterface
from password_admin.exceptions import DbError
from password_admin.exceptions import SessionNotFoundError
from password_admin.settings import settings

SESSION_ID_LEN_TO_LOG = 8


class SessionStore:
    """Manages database connections for client's sessions."""

    def __init__(self, db_factory: DbConnectionFactory) -> None:
        self.__store: TTLCache[str, DbConnectionInterface] = TTLCache(maxsize=settings.max_sessions, ttl=settings.session_duration_seconds)
        self._db_factory = db_factory
        self.__logger = logging.getLogger(self.__class__.__name__)

    def create_session(self, credentials: LoginCredentials) -> str | None:
        """Connects to database and stores connection under generated session_id.

        Args:
            credentials (LoginCredentials): Database credentials.

        Returns:
            str | None: Autogenerated session_id if connection was successful.

        Raises:
            DbConnectionError: when connection was not possible.
            DbLoginError: when credentials were invalid.
        """
        self.__logger.debug('New session requested for user %s', credentials.username)
        db_connection = self._db_factory.create()
        db_connection.login(credentials)
        self.__logger.debug('Database connection successful for user %s', credentials.username)
        session_id = self.__create_random_session_id()
        while session_id in self.__store:
            session_id = self.__create_random_session_id()
        self.__store[session_id] = db_connection
        self.__logger.debug('Session for user %s created with id %s...', credentials.username, session_id[:SESSION_ID_LEN_TO_LOG])
        return session_id

    def __create_random_session_id(self) -> str:
        return secrets.token_urlsafe(settings.session_id_length)

    def destroy_session(self, session_id: str) -> None:
        """Disconnects from database and removes stored session.

        Args:
            session_id (str): Session id to remove.

        Raises:
            DbConnectionError: when connection was not possible.
        """
        self.__logger.debug('Session with id %s destroy requested', session_id[:SESSION_ID_LEN_TO_LOG])
        try:
            db_connection = self.__store.pop(session_id)
        except KeyError:
            return
        else:
            self.__logger.debug('Session with id %s destroyed', session_id[:SESSION_ID_LEN_TO_LOG])
        with contextlib.suppress(DbError):
            db_connection.logout()

    def get_db_connection(self, session_id: Annotated[str | None, Cookie()] = None) -> DbConnectionInterface:
        """Returns database connection for session_id if found.

        Args:
            session_id (str, optional): Session id read from cookie.

        Raises:
            SessionNotFoundError: When no session found.

        Returns:
            DbConnectionInterface: Found database connection.
        """
        if not session_id:
            raise SessionNotFoundError
        self.__logger.debug('Database connection for session id %s requested', session_id[:SESSION_ID_LEN_TO_LOG])
        try:
            db_connection = self.__store[session_id]
        except KeyError as e:
            raise SessionNotFoundError from e
        else:
            self.__logger.debug('Database connection for session id %s found', session_id[:SESSION_ID_LEN_TO_LOG])
            return db_connection
